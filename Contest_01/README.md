- Next Permutation (31)

Conceito: Encontrar a próxima permutação lexicográfica usando identificação do pivô, troca com o sucessor e reversão do sufixo.

- Search in Rotated Sorted Array (33)

Conceito: Utilizar busca binária modificada para lidar com arrays rotacionados, identificando qual parte está ordenada.

- Find First and Last Position of Element in Sorted Array (34)

Conceito: Duas buscas binárias para encontrar os limites (primeira e última ocorrência) de um elemento.

- Valid Sudoku (36)

Conceito: Verificar duplicatas em linhas, colunas e sub-boxes (3×3) usando estruturas como hash ou arrays booleanos.

- Rotate Array (189)

Conceito: Rotacionar um array in-place usando a técnica de reversão em três passos.

- Combination Sum (39)

Conceito: DFS e backtracking para gerar todas as combinações que somam um determinado target (com reutilização de elementos).

- Combination Sum II (40)

Conceito: Similar ao anterior, mas cada número pode ser usado uma única vez e é necessário lidar com duplicatas de forma eficiente.

- Jump Game II (45)

Conceito: Abordagem greedy para determinar o número mínimo de saltos necessários para alcançar o final do array.

- Minimum Index Sum of Two Lists (599)

Conceito: Uso de hash maps para encontrar interseções entre duas listas e calcular a soma dos índices, escolhendo o menor.

- Subsets (78)

Conceito: Gerar todos os subconjuntos de um conjunto usando DFS/backtracking, praticando a ideia de “escolher ou não escolher” cada elemento.

- Permutations (46)

Conceito: Gerar todas as permutações de um array, reforçando o uso de recursão e backtracking para explorar todas as ordens possíveis.

- Letter Combinations of a Phone Number (17)

Conceito: Gerar combinações de letras com base em dígitos de telefone, utilizando backtracking para explorar todas as possibilidades.


